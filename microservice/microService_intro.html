<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microservices</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
   
</head>
<body>
    <div id="include-index"></div>

    <script>
        fetch('../codingcure.html')
        .then(response => response.text())
        .then(data => {
            document.getElementById('include-index').innerHTML = data;
        });
    </script>
 <button id="scrollToTopBtn" class="btn btn-primary rounded-circle position-fixed" title="Go to top" style="bottom: 20px; right: 20px; display: none;">
    <i class="fas fa-arrow-up"></i>
</button>
    <div class="container mt-4">
       <ul>
        <li><a href="#What is Monolithic Architecture">What is Monolithic Architecture</a></li>
        <li><a href="#Why Use Microservices">Why Use Microservices</a></li>
        <li><a href="#Challenges of Monolithic Architectures">Challenges of Monolithic Architectures</a></li>
        <li><a href="#What is Scaling">What is Scaling</a></li>
        <li><a href="#Pros and Cons of Microservices">Pros and Cons of Microservices</a></li>
        <li><a href="#When to Use Microservices">When to Use Microservices</a></li>
       </ul>
       <h1 class="text-center text-primary mb-4" id="What is Monolithic Architecture">What is Monolithic Architecture?</h1>
            <p>A <strong>monolithic architecture</strong> refers to a software design pattern where all components of an application are combined into a single, tightly integrated codebase. It is a traditional way of building software applications, where the entire application runs as a single unit. This design is typically characterized by its simplicity in development and deployment but can become difficult to maintain as the application grows.</p>
            
            <h3>Characteristics of Monolithic Architecture</h3>
            <ul>
                <li><strong>Single Codebase:</strong> All functionality (frontend, backend, database, etc.) resides in a single codebase. For example, user authentication, business logic, and database operations are all part of one system.</li>
                <li><strong>Tightly Coupled Components:</strong> All modules and services are interdependent, meaning changes in one part can affect others.</li>
                <li><strong>Single Deployment:</strong> The application is packaged and deployed as one executable or container. Deployment involves releasing the entire system even if only a small part of the code was modified.</li>
                <li><strong>Centralized Data Storage:</strong> A monolithic application typically uses a single database for storing and retrieving data.</li>
                <li><strong>Technology Stack:</strong> Built with a single programming language or framework for the entire application.</li>
            </ul>

       <h1 class="text-center text-primary mb-4" id="Why Use Microservices">Why Use Microservices?</h1>
        <p class="lead">
            Microservices are designed to address various challenges found in traditional monolithic architectures. A monolithic system is a single, tightly integrated codebase where all components are interconnected. While monolithic architectures served their purpose in the past, as systems grew in size and complexity, they started to reveal several limitations.
        </p>

        <h2 class="mt-4" id="Challenges of Monolithic Architectures">Challenges of Monolithic Architectures</h2>
        <ul class="list-group">
            <li class="list-group-item">
                <h3>1. Scalability</h3>
                <p><strong>Problem:</strong> In monolithic systems, scaling requires the entire application to be scaled, even if only one part is experiencing heavy load. This leads to inefficiency and high costs.</p>
                <p><strong>Example:</strong> If your app handles both user authentication and payment processing in a single monolithic structure, scaling the entire system becomes necessary even if only the payment processing requires additional resources.</p>
                <h1 class="text-center mb-4" id="What is Scaling">What is Scaling?</h1>
                <p>Scaling means making your system handle more work when demand increases (like more users visiting your website or app).</p>
            
                <div class="row">
                  <div class="col-md-6">
                    <h4>1. Vertical Scaling (Scale-Up)</h4>
                    <p>Think of this like upgrading your computer. If your computer is slow, you:</p>
                    <ul>
                      <li>Add more RAM.</li>
                      <li>Use a faster processor.</li>
                      <li>Upgrade your storage.</li>
                    </ul>
                    <p>Similarly, in vertical scaling, you make a single machine more powerful to handle more work.</p>
                    <h4>Example:</h4>
                    <p>Think of a call center. If a company gets too many calls, one employee is handling the all the calls.</p>
                    <ul>
                      <li>The company upgrade the employee's ability. like increrase work time and pays more mmoney.</li>
                    </ul>
                    <p>This is vertical scaling: improving what you already have.</p>
                  </div>
            
                  <div class="col-md-6">
                    <h4>2. Horizontal Scaling (Scale-Out)</h4>
                    <p>This is like hiring more people or adding more machines to share the work. Instead of upgrading one machine, you:</p>
                    <ul>
                      <li>Add more machines (or servers) to handle the extra workload.</li>
                    </ul>
                    <h4>Example:</h4>
                    <p>Think of a call center. If a company gets too many calls, one employee cannot handle them all, so they:</p>
                    <ul>
                      <li>Add more employees to answer the calls (horizontal scaling).</li>
                      <li>Use a call distributor to divide the incoming calls among the available employees.</li>
                      <li>Now, if the number of calls drops the next month, they can reduce the workforce or ask some employees to work part-time (scaling down)</li>
                    </ul>
                    <p>This is horizontal scaling: adding more to share the work.</p>
                  </div>
                </div>
            </li>
           
            <li class="list-group-item">
                <h3>2. Slower Development and Deployment</h3>
                <p><strong>Problem:</strong> Any change to a single component necessitates rebuilding and redeploying the entire application, slowing down development and deployment cycles.</p>
                <p><strong>Example:</strong> Updating the user interface could require redeploying the entire backend and business logic, which delays releases.</p>
            </li>
            <li class="list-group-item">
                <h3>3. Tight Coupling</h3>
                <p><strong>Problem:</strong> Components in monolithic systems are tightly coupled, meaning changes to one part may necessitate changes to other parts. This makes maintenance difficult and increases the risk of introducing bugs.</p>
                <p><strong>Example:</strong> A bug in the authentication logic might affect other features such as user profile management or checkout.</p>
            </li>
            <li class="list-group-item">
                <h3>4. Limited Flexibility</h3>
                <p><strong>Problem:</strong> Monolithic systems often use a single technology stack, which limits the ability to choose the best tools for specific tasks.</p>
                <p><strong>Example:</strong> If a new feature needs high-performance processing, but the current system doesn’t support it, you’re restricted to the existing tech stack.</p>
            </li>
            <li class="list-group-item">
                <h3>5. Deployment Bottlenecks</h3>
                <p><strong>Problem:</strong> With everything bundled in a single codebase, releasing a new version of the application can be slow, as testing and deployment become cumbersome due to the system’s complexity.</p>
            </li>
        </ul>

        <h1 class="mt-4">When to Avoid Microservices</h1>
        <ul class="list-group">
            <li class="list-group-item"><strong>Simple applications:</strong> Small apps with limited scope may not benefit from the complexity of microservices.</li>
            <li class="list-group-item"><strong>Small teams:</strong> Microservices require strong DevOps capabilities, which small teams may struggle to manage.</li>
            <li class="list-group-item"><strong>No need for scaling:</strong> Applications with minimal growth or no distinct scalability needs may not require microservices.</li>
            <li class="list-group-item"><strong>Single technology stack:</strong> If your current stack suffices for your needs, a monolith may be easier to manage.</li>
        </ul>

        <h2 class="mt-4" id="Pros and Cons of Microservices">Pros and Cons of Microservices</h2>
        <div class="row">
            <div class="col-md-6">
                <h4 class="text-success">Pros</h4>
                <ul>
                    <li><strong>Scalability:</strong> Scale individual services independently.</li>
                    <li><strong>Independent Deployment:</strong> Services can be deployed separately.</li>
                    <li><strong>Flexibility:</strong> Use the best technology for each service.</li>
                    <li><strong>Fault Isolation:</strong> Failures in one service won’t affect the entire system.</li>
                    <li><strong>Improved Productivity:</strong> Teams can work on different services concurrently.</li>
                </ul>
            </div>
            <div class="col-md-6">
                <h4 class="text-danger">Cons</h4>
                <ul>
                    <li><strong>Complexity:</strong> Managing multiple services increases system complexity.</li>
                    <li><strong>Network Latency:</strong> Inter-service communication adds latency.</li>
                    <li><strong>Data Management:</strong> Ensuring consistency across services is challenging.</li>
                    <li><strong>Operational Overhead:</strong> More services require sophisticated infrastructure.</li>
                    <li><strong>Development Overhead:</strong> Testing, versioning, and dependency management become more complex.</li>
                </ul>
            </div>
        </div>

        <h2 class="mt-4" id="When to Use Microservices">When to Use Microservices</h2>
        <ul class="list-group">
            <li class="list-group-item"><strong>Complex applications:</strong> Ideal for applications with multiple domains.</li>
            <li class="list-group-item"><strong>Frequent releases:</strong> Allow independent deployment of updates.</li>
            <li class="list-group-item"><strong>Scalability:</strong> Perfect for services with varying loads.</li>
            <li class="list-group-item"><strong>Distributed teams:</strong> Teams can work on separate services concurrently.</li>
            <li class="list-group-item"><strong>Flexibility:</strong> Different technologies can be used for different services.</li>
        </ul>

        <h2 class="mt-4">Conclusion</h2>
        <p>
            Microservices are ideal for building large, scalable, and flexible systems that need frequent updates and independent scaling. However, they come with challenges such as increased complexity and operational overhead. The decision to use microservices should be based on your application’s needs and the resources available to manage them.
        </p>
    </div> <!-- End of Bootstrap container -->

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="../scrollTop.js"></script>
</body>
</html>
